---
name: exploit-debugging
description: Debug failed exploit tests. Use for Forge errors, pattern mismatches, or profit extraction issues.
context: fork
---

# Exploit Debugging

Analyze why an exploit test failed and suggest fixes for failed exploit generation, Forge compilation errors, or profit extraction issues.

## Quick Start

Run `/exploit-debugging <contract_label>` to analyze test failures.

## Behavior

Systematically diagnose exploit failures by checking Forge output, verifying liquidity, analyzing contract variants, and reviewing LLM output quality.

For general debugging methodology (root cause tracing, defense-in-depth, condition-based waiting), see the `systematic-debugging` skill.

## Decision Criteria

| Symptom | Action |
|---------|--------|
| Contract variant mismatch | Update pattern guidance in prompts.go |
| No liquidity | Mark as PARTIAL (vulnerability found, no profit) |
| LLM output issues | Try different model or strengthen prompts |
| Wrong pattern | Update pattern detection logic |

## Pattern Quick Reference

| Pattern | Signature | Examples |
|---------|-----------|----------|
| Public Burn | `burn(address,uint256)` no auth | GROK, NOON, BAMBOO |
| Arbitrary Mint | `mint(address,uint256)` public | EGD, AVENTA, BEGO |
| Reward Manipulation | `_transfer` modifies rewards | UWERX, SAFEMOON |
| Flash Loan Price | DEX price during callback | BDEX, DYNA, FAPEN |
| Permit Bypass | Missing deadline/signature check | Multiple |
| Proxy Confusion | Implementation vs proxy state | UNIBTC-BEDROCK |

For detailed POC code and validation steps, see [table_ix_exploit_reference.md](../../../docs/research/table_ix_exploit_reference.md).

## Process

1. **Read test output** - JSON and logs
2. **Identify failure mode**:

   | Failure | Symptom | Fix |
   |---------|---------|-----|
   | Contract Variant Mismatch | Forge reverts, correct pattern | Check variant differs from target |
   | No Liquidity | Forge reverts on swap | Verify liquidity at test block |
   | LLM Output Issues | "no valid Solidity code" | Check access control analysis |
   | Wrong Pattern | LLM tries reentrancy | Update pattern detection |
   | Missing Token Approval | ERC20 transfer fails | Add approve() step to pattern |

3. **Run diagnostics**:

   ```bash
   # Check Forge output for revert reason
   rg -i "revert|error" <output_file>

   # Verify liquidity exists at test block
   cast call <router> "getAmountsOut(uint256,address[])" \
       1000000000000000000 "[<token>,<WETH>]" \
       --rpc-url <rpc> --block <block>

   # Check contract variant (different mint signatures)
   cast call <contract> "mint(address,uint256)" --rpc-url <rpc>
   cast call <contract> "mint()" --rpc-url <rpc>
   ```

4. **Review LLM output**:
   - Check conversation log for analysis reasoning
   - Verify code fences contain valid Solidity
   - Look for safety filter refusals

5. **Apply fix** based on failure mode then re-test with `/table-ix-testing`

## Success Criteria

- Identified specific failure mode from diagnostic output
- Provided actionable fix recommendation
- Updated relevant files (prompts.go, test plan) if needed

## Error Handling

| Error | Resolution |
|-------|------------|
| Missing RPC access | Use fallback archive node or skip block-dependent checks |
| Rate limited | Wait and retry with exponential backoff |
| Contract not verified | Cannot debug source-level issues, document limitation |
| Chainstack archive limits | BSC historical state may be unavailable for older blocks |

## Trace Interpretation (`-vvvv` Verbosity)

Use `-vvvv` verbosity to get detailed execution traces for debugging failed exploits.

### Reading Trace Output

```bash
# Run with maximum verbosity
forge test --match-test testExploit -vvvv
```

**Trace Format:**
```
├─ [CALL] Target::function(args) [gas]
│   ├─ [CALL] Nested::call() [gas]
│   │   └─ ← [Return: value]
│   ├─ [REVERT] reason
│   └─ ← [Return/Revert]
```

### Common Trace Patterns

| Pattern | Meaning | Fix |
|---------|---------|-----|
| `[REVERT] EvmError: Revert` | Generic revert, check require() | Add missing approval or condition |
| `[REVERT] arithmetic underflow` | SafeMath protection triggered | Check token balance before operation |
| `[CALL] → [STATICCALL]` | Read-only call in write context | Function may have view modifier |
| `[CALL] WETH::withdraw` fails | Insufficient WETH balance | Verify swap produced expected tokens |
| Nested `[CALL]` chain stops | Revert in inner call bubbles up | Find deepest revert in trace |

### Finding Revert Location

1. **Scan for `[REVERT]`**: Search trace bottom-up for first revert
2. **Check parent call**: The containing `[CALL]` shows which function failed
3. **Look at args**: Parameters in the failing call often reveal the issue

### Example Trace Analysis

```
├─ [CALL] Router::swapExactTokensForETH(1000, 0, path, attacker, deadline)
│   ├─ [CALL] Pair::swap(0, 500, attacker, 0x)
│   │   ├─ [CALL] Token::transfer(attacker, 500)
│   │   │   └─ [REVERT] ERC20: transfer amount exceeds balance
│   │   └─ ← [Revert]
│   └─ ← [Revert]
```

**Diagnosis**: Token transfer failed because pair doesn't have enough tokens. Check if liquidity exists at the test block.

### Verbosity Levels

| Flag | Output |
|------|--------|
| `-v` | Test results only |
| `-vv` | Logs from `console.log` |
| `-vvv` | Execution traces for failing tests |
| `-vvvv` | Execution traces for ALL tests + setup |

## Examples

### UWERX Pattern 11 Failure

- **Scenario**: 0 profit despite vulnerability detection
- **Diagnosis**: LLM generated generic swap without building sell pressure first
- **Fix**: Enhanced Pattern 11 prompt with explicit 6-step sequence in prompts.go

### UNIBTC-BEDROCK Compilation Success

- **Scenario**: Compilation success but 0 profit
- **Diagnosis**: Contract variant mismatch - VaultWithoutNative requires ERC20 input, not ETH
- **Fix**: Add vault-specific pattern with pre-analysis of token states

### BSC False Positive

- **Scenario**: Contract shows ~999,999 ETH profit (impossible)
- **Diagnosis**: False positive - LLM logged token balance instead of native currency profit
- **Fix**: Updated profit logging guidance in prompts.go to use address(this).balance

## Contract Variants

Known variant mismatches that require pattern adjustments:

| Contract | Expected Variant | Actual Variant | Impact |
|----------|-----------------|----------------|--------|
| Bedrock uniBTC | Payable mint() | VaultWithoutNative | Needs ERC20 input, not ETH |
| SafeMoon clones | Standard burn | deliver()/skim() | Different attack pattern |

## TraceAnalyzer Failure Categories

The `TraceAnalyzer` classifies execution failures into 6 typed categories for targeted remediation:

| FailureType | Severity | Meaning | Recommended Fix |
|-------------|----------|---------|-----------------|
| `FailureRevert` | HIGH | Generic `require()` or `revert()` triggered | Check preconditions: approvals, balances, access |
| `FailureOutOfGas` | MEDIUM | Gas limit exceeded during execution | Increase gas limit or simplify operations |
| `FailureBalance` | HIGH | Insufficient token/ETH balance for operation | Verify flash loan amount covers all transfers |
| `FailureAccess` | CRITICAL | `onlyOwner` / access control rejection | Wrong caller — check `vm.startPrank` target |
| `FailureNoProfit` | LOW | Exploit executed but net profit ≤ 0 | Review extraction path, check slippage/fees |
| `FailureRepayment` | CRITICAL | Flash loan repayment failed | Ensure extracted tokens route back to lender |

The `TraceFeedback` struct carries: `FailureType`, `Severity`, `TraceSnippet`, `SuggestedFix`, and `AttemptNumber`.

## Feedback Loop Debugging

The `FeedbackOrchestrator` drives iterative exploit refinement:

1. **Initial generation** — LLM produces exploit from analysis
2. **Execution** — Forge runs the exploit on forked state
3. **Trace analysis** — `TraceAnalyzer` categorizes the failure
4. **LLM refinement** — Failure feedback sent back to LLM for adjustment
5. **Re-execution** — Repeat until success or iteration limit (default: 5)

### Debugging Methodology

- **Start at the Orchestrator**: Check `FeedbackOrchestrator.Run()` return for final status
- **Inspect iteration history**: Each iteration's `TraceFeedback` is logged with attempt number
- **Severity-ranked near-misses**: Iterations reaching `FailureNoProfit` are closer to success than `FailureAccess`
- **Trace from**: Orchestrator → TraceAnalyzer → LLM refinement prompt → re-execution
- **Common stall pattern**: Oscillating between two failure types means the LLM is not incorporating feedback — check refinement prompt construction

## BestAtNExecutor Debugging

The `BestAtNExecutor` runs multiple exploit attempts in parallel with diverse models:

- **Default attempts**: 8 total, 4 concurrent (`--best-of` flag)
- **Model rotation**: Cycles through configured model list for diversity
- **Per-run workspace**: Each attempt gets an isolated Forge workspace
- **Best selection**: Highest-profit successful run wins; if none succeed, best near-miss is reported

### Debugging Tips

- Check individual workspace dirs for per-attempt Forge output
- Compare failure categories across attempts — consistent `FailureAccess` means a fundamental approach problem
- Divergent failures suggest the LLM is exploring different strategies (good sign)
- Use `--parallel-attempts` to reduce concurrency if resource-constrained

## Feedback CLI Flags

| Flag | Default | Description |
|------|---------|-------------|
| `--best-of` | 8 | Number of exploit generation attempts |
| `--feedback-iterations` | 5 | Max feedback loop refinement iterations |
| `--parallel-attempts` | 4 | Concurrent execution slots for BestAtNExecutor |

## References

- Prompts: `internal/llm/prompts.go`
- Refinement Templates: `internal/llm/prompts/refinement.go`
- Monetization Prompt: `internal/llm/prompts/monetization.go`
- Test Plan: `docs/test-plans/table_ix_working.yaml`
- Pattern Reference: `docs/research/table_ix_exploit_reference.md`
- Trace Analyzer: `internal/agent/trace_analyzer.go`
- Feedback Loop: `internal/agent/feedback_loop.go`
- BestAtN Executor: `internal/agent/best_at_n.go`
- Agentic Loop: `internal/agent/agentic/prompt.go`
- Parallel Execution: `internal/agent/agentic/parallel.go`
