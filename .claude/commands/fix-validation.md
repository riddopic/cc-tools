---
description: Fix validation issues found during code review
allowed-tools:
  - Read
  - Grep
  - Glob
  - Bash
  - Edit
  - Write
  - Task
  - TaskCreate
  - TaskUpdate
  - TaskList
model: opus
skills:
  - tdd-workflow
  - testing-patterns
  - systematic-debugging
---

# Fix Validation Issues

## Component: $ARGUMENTS

Automatically review validation reports and implement fixes for identified issues in the Quanta project. This command reads the validation report generated by `/validate-command` and systematically fixes all critical and major issues found.

**Input Files**:

- Validation Report: `docs/validation/{component}-validation.md` (latest)
- User Guide: `docs/USER-GUIDE/{COMPONENT}.md`

**Output Files**:

- Fix Summary: `docs/validation/{component}-fixes-{timestamp}.md`
- Updated source files with fixes applied
- Updated/created test files following TDD

**Supported Components**:

- `blockchain` - Fix blockchain command issues
- `dex` - Fix DEX integration issues
- `analyze` - Fix analysis command issues
- `doctor` - Fix diagnostics issues
- `export` - Fix export functionality issues
- `report` - Fix report generation issues
- `run` - Fix main exploit generation issues
- `target` - Fix target configuration issues
- `all` - Fix all components with issues

Example usage:

- `/fix-validation blockchain` - Fixes issues found in blockchain validation
- `/fix-validation all` - Fixes all components with validation issues

## Agent Orchestration Strategy

**IMPORTANT**: Think carefully about this, and instruct all sub-agents to do the same.

Use the **product-manager-orchestrator** to coordinate specialized agents based on issue types:

### Primary Fix Agents

1. **backend-systems-engineer** - Implement missing Go features

   - Replace mock implementations with real code
   - Wire up internal packages to commands
   - Implement missing functionality
   - Fix integration issues

2. **qa-test-engineer** - Fix test coverage issues

   - Write missing tests following TDD
   - Improve test coverage to ≥80%
   - Add table-driven tests
   - Create integration tests

3. **code-refactoring-expert** - Fix code quality issues

   - Remove mock implementations
   - Fix Go idiom violations
   - Improve error handling
   - Reduce complexity

4. **security-threat-analyst** - Fix security issues

   - Remove hardcoded values
   - Fix credential handling
   - Add input validation
   - Remove sensitive data from logs

5. **dependency-manager** - Fix dependency issues
   - Update go.mod dependencies
   - Resolve version conflicts
   - Remove unused dependencies

### Supporting Agents

6. **senior-software-engineer** - Architectural fixes

   - Fix interface violations
   - Improve package structure
   - Fix dependency injection

7. **performance-optimizer** - Performance fixes

   - Add missing benchmarks
   - Optimize slow operations
   - Fix resource leaks

8. **technical-docs-writer** - Documentation fixes
   - Update godoc comments
   - Fix USER-GUIDE documentation
   - Add missing examples

## Execution Process

### Step 1: Load Validation Report

Find and read the latest validation report:

```bash
# Find latest validation report for component
ls -t docs/validation/${component}-validation-*.md | head -1

# Read validation report to identify issues
cat docs/validation/${component}-validation-{latest}.md
```

Parse the validation report to extract:

- Overall score
- Critical issues (blocks deployment)
- Major issues (should fix)
- Minor issues (consider fixing)
- Specific file locations and line numbers

### Step 2: Prioritize Fixes

**Fix Order** (MUST follow this sequence):

1. **Critical Issues First**:

   - Mock implementations → Real implementations
   - Missing core functionality
   - Security vulnerabilities
   - Compilation errors

2. **Major Issues Second**:

   - Missing tests (write tests FIRST per TDD)
   - Interface violations
   - Error handling issues
   - Go idiom violations

3. **Minor Issues Last**:
   - Documentation improvements
   - Performance optimizations
   - Code organization

### Step 3: Implement Fixes

#### For Mock Implementation Issues (Most Common)

**Example from blockchain validation**:

```go
// ❌ BEFORE: Mock implementation in cmd/blockchain_utils.go
type minimalSourceFetcher struct{}

func (f *minimalSourceFetcher) FetchSource(ctx context.Context, address string) (*types.ContractSource, error) {
    // Returns mock data
    return &types.ContractSource{
        ContractName: "MockContract",
        SourceCode:   "// Mock source code",
    }, nil
}

// ✅ AFTER: Use real implementation
import (
    "github.com/riddopic/quanta/internal/blockchain/source"
    "github.com/riddopic/quanta/internal/blockchain/explorer"
)

func initializeSourceFetcher(chainID types.ChainID, rpcURL, apiKey string) source.Orchestrator {
    config := &source.Config{
        ChainID: chainID,
        RPC:     rpcURL,
        APIKey:  apiKey,
    }

    explorerClient := explorer.NewClient(config)
    return source.NewOrchestrator(
        source.WithExplorer(explorerClient),
        source.WithCache(true),
    )
}
```

#### For Missing Test Coverage

**Write tests FIRST (TDD Red-Green-Refactor)**:

```go
// Step 1: Write failing test (RED)
func TestBlockchainDetectCommand(t *testing.T) {
    tests := []struct {
        name    string
        args    []string
        wantErr bool
    }{
        {
            name:    "valid ethereum address",
            args:    []string{"--chain", "ethereum", "--address", "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48"},
            wantErr: false,
        },
        {
            name:    "invalid address",
            args:    []string{"--chain", "ethereum", "--address", "invalid"},
            wantErr: true,
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            cmd := newDetectCommand()
            cmd.SetArgs(tt.args)
            err := cmd.Execute()
            if (err != nil) != tt.wantErr {
                t.Errorf("Execute() error = %v, wantErr %v", err, tt.wantErr)
            }
        })
    }
}

// Step 2: Make test pass (GREEN)
// Step 3: Refactor if needed
```

#### For Interface Violations

```go
// Define interfaces BEFORE implementations
type ProxyDetector interface {
    DetectProxy(ctx context.Context, address string) (*ProxyInfo, error)
}

type SourceFetcher interface {
    FetchSource(ctx context.Context, address string) (*ContractSource, error)
}

// Ensure implementations satisfy interfaces
var _ ProxyDetector = (*proxyDetectorImpl)(nil)
var _ SourceFetcher = (*sourceFetcherImpl)(nil)
```

### Step 4: Validate Each Fix

After implementing fixes for each category:

```bash
# 1. Ensure compilation
go build ./cmd/... ./internal/...

# 2. Run tests for affected packages
go test -v ./cmd -run TestBlockchain
go test -v ./internal/blockchain/...

# 3. Check coverage improvement
go test -coverprofile=coverage.out ./...
go tool cover -func=coverage.out | grep blockchain

# 4. Run linting
golangci-lint run ./cmd/blockchain*.go

# 5. Verify no mocks remain
! grep -r "mock" cmd/blockchain*.go | grep -v "_test.go"
```

### Step 5: Generate Fix Summary Report

Create `docs/validation/{component}-fixes-{timestamp}.md`:

````markdown
# {Component} Validation Fixes

**Date**: {timestamp}
**Original Score**: X/10
**New Score**: Y/10
**Status**: ✅ Production Ready / ⚠️ Needs Review

## Issues Fixed

### Critical Issues (X fixed)

1. ✅ Replaced mock implementation in cmd/blockchain_utils.go
   - Used internal/blockchain/source package
   - Connected real Explorer client
2. ✅ Fixed security vulnerability in credential handling
   - Removed hardcoded test addresses
   - Added proper environment variable usage

### Major Issues (Y fixed)

1. ✅ Added missing tests for command execution

   - Created blockchain_detect_test.go
   - Coverage increased from 0% to 85%

2. ✅ Fixed interface violations
   - Defined ProxyDetector interface
   - Implemented proper dependency injection

### Minor Issues (Z fixed)

1. ✅ Added godoc comments to exported functions
2. ✅ Improved error messages with context

## Validation Results

### Before Fixes

- Build: ❌ Using mocks
- Tests: ❌ 0% coverage on commands
- Lint: ✅ Passing
- Security: ❌ Hardcoded values

### After Fixes

- Build: ✅ Real implementations
- Tests: ✅ 85% coverage
- Lint: ✅ Passing
- Security: ✅ No hardcoded values

## Files Modified

1. cmd/blockchain_utils.go - Replaced mocks with real implementations
2. cmd/blockchain_detect.go - Fixed runDetectCommand
3. cmd/blockchain_detect_test.go - Added comprehensive tests
4. cmd/blockchain_fetch.go - Integrated real source fetcher
5. cmd/blockchain_verify.go - Combined real implementations

## Commands to Verify

\```bash

# Test the fixed command

quanta blockchain detect --chain ethereum --address 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48

# Run tests

go test ./cmd -v -run TestBlockchain

# Check coverage

task coverage
\```

## Next Steps

1. Run full validation: `/validate-command blockchain`
2. Test in staging environment
3. Update documentation if needed
````

## Fix Verification Process

Follow `verification-before-completion` before reporting fixes complete. When dispatching independent fix agents, follow `dispatching-parallel-agents` patterns.

After all fixes are applied:

1. **Re-run Validation**:

   ```bash
   # Re-validate the component
   /validate-command {component}

   # Score should now be ≥8/10
   ```

2. **Run Full Test Suite**:

   ```bash
   task test         # All tests must pass
   task test-race    # No race conditions
   task coverage     # Coverage ≥80%
   ```

3. **Verify Production Readiness**:
   ```bash
   task lint         # No linting errors
   task build        # Successful build
   task check        # All checks pass
   ```

## Common Fix Patterns

### Pattern 1: Replacing Mock with Real Implementation

```go
// Step 1: Import real packages
import (
    "github.com/riddopic/quanta/internal/blockchain/proxy"
    "github.com/riddopic/quanta/internal/blockchain/source"
    "github.com/riddopic/quanta/internal/blockchain/explorer"
)

// Step 2: Initialize real components
func initializeComponents(cfg *Config) (*Components, error) {
    explorerClient := explorer.NewClient(&explorer.Config{
        ChainID: cfg.ChainID,
        APIKey:  cfg.APIKey,
    })

    proxyDetector := proxy.NewDetector(
        proxy.WithExplorer(explorerClient),
        proxy.WithRPC(cfg.RPCURL),
    )

    sourceFetcher := source.NewOrchestrator(
        source.WithExplorer(explorerClient),
        source.WithStrategy(cfg.Strategy),
    )

    return &Components{
        Proxy:  proxyDetector,
        Source: sourceFetcher,
    }, nil
}

// Step 3: Use in command
func runDetectCommand(cmd *cobra.Command, args []string) error {
    components, err := initializeComponents(config)
    if err != nil {
        return fmt.Errorf("initializing components: %w", err)
    }

    result, err := components.Proxy.DetectProxy(ctx, address)
    if err != nil {
        return fmt.Errorf("detecting proxy: %w", err)
    }

    // Output real results
    fmt.Printf("Proxy Type: %s\n", result.Type)
    fmt.Printf("Implementation: %s\n", result.Implementation)
    return nil
}
```

### Pattern 2: Adding Missing Tests

```go
// Always write test FIRST (TDD)
func TestCommandIntegration(t *testing.T) {
    // Arrange
    mockExplorer := mocks.NewMockExplorer(t)
    mockExplorer.EXPECT().
        GetContract(mock.Anything, mock.Anything).
        Return(&types.Contract{
            Address: "0x123",
            IsProxy: true,
        }, nil)

    // Act
    cmd := newCommand()
    cmd.SetArgs([]string{"--chain", "ethereum", "--address", "0x123"})
    err := cmd.Execute()

    // Assert
    assert.NoError(t, err)
    mockExplorer.AssertExpectations(t)
}
```

## Critical Reminders

1. **TDD is MANDATORY** - Write failing test first, then fix
2. **Fix Root Causes** - Don't just suppress symptoms
3. **Validate Continuously** - Test after each fix
4. **Use Real Implementations** - No mocks in production code
5. **Follow Go Idioms** - Reference CODING_GUIDELINES.md

## Usage Examples

```bash
# Fix blockchain command issues
/fix-validation blockchain

# Fix all components with issues
/fix-validation all

# After fixes, re-validate
/validate-command blockchain
```

**IMPORTANT**: The goal is to achieve a validation score of ≥8/10 and have all critical/major issues resolved. The component should be production-ready after fixes are applied.
