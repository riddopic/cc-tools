# Context Audit: cc-tools

**Date:** 2026-02-14T05:17:57Z
**Scope:** Full codebase (`/Users/riddopic/git/cc-stuff/q2`)
**Auditor:** Claude Opus 4.6 — ultra-granular micro-analysis

---

## Module Map

```
cc-tools/
├── cmd/cc-tools/           # CLI entrypoint (5 files, 1,476 lines)
│   ├── main.go             # Arg parsing, hook registry, session commands
│   ├── config.go           # Config subcommand handlers
│   ├── debug.go            # Debug subcommand handlers
│   ├── mcp.go              # MCP subcommand handlers
│   └── skip.go             # Skip/unskip subcommand handlers
│
├── internal/
│   ├── hooks/              # Core validation engine (10 production files)
│   │   ├── dependencies.go # DI: CommandRunner, ProcessManager, Clock, InputReader, OutputWriter
│   │   ├── validate.go     # ParallelValidateExecutor, result formatting
│   │   ├── validate_skip.go# Entry point: ValidateWithSkipCheck
│   │   ├── discovery.go    # Multi-language command discovery (496 lines)
│   │   ├── executor.go     # Command execution with timeout + lock
│   │   ├── input.go        # HookInput JSON parsing from Claude Code
│   │   ├── lock.go         # Process lock with stale detection
│   │   ├── format.go       # ANSI result formatting
│   │   └── errors.go       # Sentinel errors
│   │
│   ├── hookcmd/            # Hook event dispatcher (3 files)
│   │   ├── hookcmd.go      # Dispatch() routes events to handlers
│   │   ├── handler.go      # Handler interface, RunHandlers with panic recovery
│   │   └── input.go        # HookInput parsing (different struct from hooks/)
│   │
│   ├── config/             # Configuration management (2 files, 896 lines)
│   │   ├── config.go       # Config struct wrapping HooksConfig
│   │   └── manager.go      # Manager with 17 keys, 7 sections, JSON persistence
│   │
│   ├── skipregistry/       # Skip registry (4 files, 587 lines)
│   │   ├── types.go        # SkipType, RegistryEntry, sentinel errors
│   │   ├── interfaces.go   # Reader, Writer, Storage, Registry
│   │   ├── registry.go     # JSONRegistry with RWMutex, lazy loading
│   │   └── storage.go      # JSONStorage with atomic write-then-rename
│   │
│   ├── session/            # Session management (3 files, 404 lines)
│   │   ├── store.go        # JSON-file session store (Save/Load/List/Search)
│   │   ├── alias.go        # AliasManager for friendly session names
│   │   └── transcript.go   # JSONL transcript parser
│   │
│   ├── mcp/                # MCP server management (1 file, 287 lines)
│   │   └── mcp.go          # Wraps `claude mcp` CLI commands
│   │
│   ├── debug/              # Debug logging (2 files, 350 lines)
│   │   ├── config.go       # Per-directory debug enable/disable, migration
│   │   └── logger.go       # Thread-safe logger with Logf/LogSection/LogError
│   │
│   ├── output/             # Terminal output (3 files, 284 lines)
│   │   ├── output.go       # Lipgloss-styled Terminal with mutex
│   │   ├── hook.go         # Raw ANSI HookFormatter for Claude Code
│   │   └── table.go        # Lipgloss-based table renderer
│   │
│   ├── compact/            # Compaction suggestions (2 files, 123 lines)
│   │   ├── suggest.go      # Tool call counter, /compact suggestion
│   │   └── log.go          # Compaction event logging
│   │
│   ├── observe/            # JSONL event recording (2 files, 135 lines)
│   │   ├── observe.go      # Observer.Record() with rotation
│   │   └── archive.go      # RotateIfNeeded() timestamped archival
│   │
│   ├── notify/             # Notifications (3 files, 195 lines)
│   │   ├── audio.go        # AudioPlayer with quiet hours
│   │   ├── desktop.go      # Desktop notifications via osascript
│   │   └── quiethours.go   # Time-range quiet hours (overnight support)
│   │
│   ├── superpowers/        # Skill injection (1 file, 76 lines)
│   │   └── inject.go       # Reads SKILL.md → hookSpecificOutput JSON
│   │
│   ├── pkgmanager/         # JS package manager detection (1 file, 68 lines)
│   │   └── detect.go       # Lock file detection + .env writing
│   │
│   └── shared/             # Cross-cutting utilities (5 files, 510 lines)
│       ├── fs.go           # HooksFS, RegistryFS, FS interfaces + RealFS
│       ├── project.go      # FindProjectRoot, DetectProjectType, ShouldSkipFile
│       ├── configdir.go    # XDG-compliant ConfigDir()
│       ├── debug_paths.go  # SHA256-hashed debug log paths
│       └── colors.go       # Raw ANSI + lipgloss color helpers
│
├── go.mod                  # Go 1.26, 2 direct deps (lipgloss, testify)
└── Taskfile.yml            # Build/test/lint task runner
```

**Totals:** 45 production source files, ~7,055 lines production code, ~12,310 lines test code (1.74:1 test-to-production ratio). 14 internal packages + 1 cmd package. 10 mock files via Mockery v3.5.

---

## Function Micro-Analyses

### cmd/cc-tools/main.go (629 lines)

**`main()`** (lines 42-80): Creates Terminal, calls `debugLog()`, dispatches on `os.Args[1]` via a switch statement. No Cobra — raw arg parsing throughout. Exits with code 1 for unknown commands.

**`debugLog()`** (lines 561-618): Unconditionally logs every invocation to a per-directory debug file. For `validate` and `hook` commands, reads stdin entirely, writes it to a temp file, then replaces `os.Stdin` with that temp file so downstream readers can still consume it. The temp file path is tracked in global `stdinTempFile` for cleanup.

**`buildHookRegistry()`** (lines 166-178): Creates a static map of event names → handler chains. Seven events registered: SessionStart (superpowers + pkgmanager), PreToolUse (compact + observe), PostToolUse (observe), PostToolUseFailure (observe), PreCompact (log compaction), Stop (guard), Notification (audio + desktop).

**`runHookCommand()`** (lines 123-152): Translates CLI subcommand names to Claude Code event names via `hookEventMap`. Accepts unknown events gracefully. Always exits 0 on parse errors (hooks must not block Claude Code).

**`loadValidateConfig()`** (lines 512-540): Loads timeout and cooldown from config file, then allows environment variable overrides (`CC_TOOLS_HOOKS_VALIDATE_TIMEOUT_SECONDS`, `CC_TOOLS_HOOKS_VALIDATE_COOLDOWN_SECONDS`). Defaults: 60s timeout, 5s cooldown.

### internal/hooks/discovery.go (496 lines)

**`DiscoverCommand()`**: Walks upward from file directory to project root, checking each level for task runner targets (Makefile, Taskfile.yml, justfile), package.json scripts, scripts/ directory executables, then language-specific defaults. For task runners, validates target existence via dry-run commands (`make -n`, `task --dry`, `just --show`).

**Language-specific detection**: Go uses `golangci-lint run` (fallback: `go vet`) for lint, `go test ./...` for test. Rust uses `cargo clippy` / `cargo test`. Python uses `ruff` (fallback: flake8, pylint) / `pytest`.

**JS package manager**: Auto-detected from lock files (yarn.lock → yarn, pnpm-lock.yaml → pnpm, bun.lockb → bun, default → npm). Scripts verified via `jq` extraction from package.json.

### internal/hooks/validate.go (322 lines)

**`ParallelValidateExecutor.ExecuteValidations()`**: Discovers lint and test commands, launches both via `sync.WaitGroup.Go()` goroutines. Results are written to pointer targets that are collected after `wg.Wait()`. Nil results (command not found) do not count as failures.

**`FormatMessage()`**: Returns empty string on success (no output needed). On failure, formats ANSI-colored blocking error with exact commands to reproduce, including `cd` to working directory. Uses `ExitCodeShowMessage` (2) to signal Claude Code should surface the message.

### internal/hooks/lock.go (154 lines)

**`TryAcquire()`**: Generates lock file path in `/tmp` using SHA256 hash of workspace path. Uses `os.OpenFile(O_CREATE|O_EXCL)` for atomic creation. If lock exists, checks if holding PID is still alive via `syscall.Signal(0)`. Stale locks (dead PID) are cleaned up and re-acquired. Records cooldown timestamp on release.

**Cooldown**: After releasing a lock, writes current timestamp. Next acquire checks if cooldown period has elapsed since last run, returning `ErrCooldown` if too soon. Prevents rapid re-validation.

### internal/hooks/executor.go (166 lines)

**`Execute()`**: Wraps command in `context.WithTimeout()`, runs via `exec.CommandContext()`. Captures stdout+stderr into buffers. On timeout, sets `TimedOut` flag and preserves partial output. Extracts exit code via `errors.As(*exec.ExitError)`, falling back to -1.

### internal/hooks/input.go (85 lines)

**`ReadHookInput()`**: Detects terminal vs pipe by checking `ModeCharDevice`. Returns `ErrNoInput` for terminals. Reads all data from reader, validates non-empty, unmarshals JSON into `HookInput` struct.

**`GetFilePath()`**: Parses `tool_input` RawMessage on-demand. NotebookEdit uses `notebook_path` field; all other tools use `file_path`.

**`IsEditTool()`**: Whitelist of 4 tools: Edit, MultiEdit, Write, NotebookEdit.

### internal/config/manager.go (844 lines)

**`Manager`**: Manages 17 configuration keys organized into 7 sections. JSON file at `~/.config/cc-tools/config.json`. Supports `Get(key)`, `Set(key, value)`, `Reset(key)`, `ResetAll()`, `GetAll()`, `GetConfig()`.

**Backward compatibility**: `Load()` handles legacy map-based config format by re-marshaling into structured `Values` type. All keys have type validation (int, bool, string) with descriptive error messages showing valid values.

**Key sections**: validate (timeout, cooldown), notifications (enabled, cooldown), compact (threshold, reminder_interval), notify.audio (enabled, directory), notify.desktop (enabled), observe (enabled, max_file_size_mb), learning (enabled), pre_commit (lint_skip_msg, test_skip_msg).

### internal/skipregistry/registry.go (319 lines)

**`JSONRegistry`**: Thread-safe with `sync.RWMutex`. Lazy loading — data loaded on first access. CRUD operations: Skip (add entry), Unskip (remove entry), IsSkipped (check with parent traversal), ListAll, ListSkipped (active only), Clean (remove stale entries).

**Parent traversal**: `IsSkipped()` checks current directory, then walks up to parent directories. If a parent directory has a skip entry, child directories inherit the skip.

**Cache with rollback**: Modifying operations update in-memory cache first, then persist. If save fails, the in-memory state is rolled back to the previous value.

### internal/mcp/mcp.go (287 lines)

**`Manager`**: Wraps `claude mcp` CLI commands. `List()` reads `~/.claude/settings.json` directly to get server configs (name, type, scope). `Enable/Disable()` call `claude mcp enable/disable` with `--scope user` flag.

**Flexible matching**: `findBestMatch()` supports exact, case-insensitive, and prefix/contains matching. Multiple matches return an error listing all candidates.

### internal/shared/project.go (212 lines)

**`FindProjectRoot()`**: Walks upward looking for project markers: `.git`, `go.mod`, `Cargo.toml`, `package.json`, `pyproject.toml`, `Makefile`, `Taskfile.yml`, `justfile`. Returns first directory containing any marker.

**`DetectProjectType()`**: Returns language string (go, rust, javascript, typescript, python, ruby, java, unknown) based on marker files.

**`ShouldSkipFile()`**: Skips files matching patterns: `node_modules/`, `vendor/`, `.git/`, `dist/`, `build/`, `__pycache__/`, and files ending with common binary/lock extensions.

### internal/session/store.go (196 lines)

**`Store`**: Reads session metadata JSON files from `~/.claude/sessions/`. `List()` reads all `.json` files, sorts by date descending, returns up to limit. `Search()` does case-insensitive substring matching on ID and title. `FindByDate()` filters by date prefix.

**`Save()`**: Writes atomically via temp-file-then-rename. Sets `ModifiedAt` to current time.

### internal/hookcmd/ (3 files, 196 lines)

**`Dispatch()`** (21 lines): Looks up event name in registry, calls `RunHandlers()`. Always returns 0 (hooks never block).

**`RunHandlers()`** (31 lines): Iterates handlers sequentially. Each handler is wrapped in a `defer/recover` that captures panics — a panicking handler cannot crash the hook pipeline.

**`ParseInput()`** (88 lines): Reads stdin, unmarshals into `HookInput` struct. This is a different struct than `hooks.HookInput` — the `hookcmd` version has additional fields (`StopHookActive`, `TranscriptPath`) and different JSON tags.

---

## Global Understanding

### State & Invariants

#### File-System State

| State | Location | Format | Protected By |
|-------|----------|--------|-------------|
| Configuration | `~/.config/cc-tools/config.json` | JSON (17 keys) | Atomic write-rename |
| Debug config | `~/.config/cc-tools/debug-config.json` | JSON (dir → bool map) | `sync.RWMutex` |
| Skip registry | `~/.config/cc-tools/skip-registry.json` | JSON (dir → skip entries) | `sync.RWMutex` + rollback |
| Session metadata | `~/.claude/sessions/*.json` | JSON per session | Atomic write-rename |
| Session aliases | `~/.claude/session-aliases.json` | JSON (alias → session ID) | File-level |
| Process locks | `/tmp/cc-tools-validate-*.lock` | PID file | `O_CREATE|O_EXCL` |
| Cooldown markers | `/tmp/cc-tools-validate-*.cooldown` | Timestamp file | File-level |
| Debug logs | `~/.cache/cc-tools/debug/*.log` | Append-only text | `sync.Mutex` |
| Observations | `~/.cache/cc-tools/observations/events.jsonl` | JSONL append-only | Rotation by size |
| Compact state | `~/.cache/cc-tools/compact/` | JSON per session | File-level |

#### Cross-Function Invariants

1. **Hooks never block Claude Code**: All hook handlers exit 0 on errors. Parse failures in `runHookCommand()` call `os.Exit(0)`. Panic recovery in `RunHandlers()` prevents crashes.

2. **Atomic file operations**: `skipregistry.JSONStorage.Save()`, `session.Store.Save()` use write-to-temp-then-rename. `hooks.LockManager` uses `O_EXCL` for atomic creation.

3. **Registry consistency**: `JSONRegistry` rolls back in-memory cache if persistence fails, preventing memory/disk divergence.

4. **Lock liveness**: Stale lock detection via `process.Signal(0)` ensures dead processes don't permanently block validation.

5. **Config layering**: config file → environment variable override (`CC_TOOLS_HOOKS_VALIDATE_*`). Env vars always win.

6. **Skip inheritance**: Skip entries propagate to child directories via prefix matching in `IsSkipped()`.

7. **Debug log isolation**: Each working directory gets its own log file via SHA256 hash of the absolute path.

### Workflows

#### Workflow 1: Validation (PostToolUse → validate)

```
Claude Code edit → cc-tools validate (via PostToolUse hook)
  ├── debugLog(): Log args + stdin to per-directory file
  ├── loadValidateConfig(): Config file → env override → (timeout, cooldown)
  └── ValidateWithSkipCheck():
      ├── ReadHookInput(): Stdin JSON → HookInput
      ├── IsEditTool() guard: Only Edit/MultiEdit/Write/NotebookEdit
      ├── GetFilePath(): Extract file path from tool_input
      ├── ShouldSkipFile(): Binary/vendor/node_modules check
      ├── FindProjectRoot(): Walk up for .git/go.mod/etc.
      ├── CheckSkipRegistry(): skipregistry.IsSkipped(projectRoot)
      ├── TryAcquire lock: /tmp/cc-tools-validate-{hash}.lock
      │   ├── O_EXCL atomic create (success → continue)
      │   ├── PID alive check (stale → reclaim)
      │   └── Cooldown check (too recent → skip)
      └── ParallelValidateExecutor:
          ├── DiscoverCommand(lint): Makefile→Taskfile→justfile→pkg.json→lang
          ├── DiscoverCommand(test): Same priority chain
          ├── goroutine: Execute(lint command, timeout)
          ├── goroutine: Execute(test command, timeout)
          └── FormatMessage() → exit code (0=pass, 2=show-message)
```

#### Workflow 2: Hook Event Dispatch (any hook event)

```
Claude Code event → cc-tools hook <event-type>
  ├── debugLog(): Log invocation
  ├── hookEventMap: CLI name → Claude Code event name
  ├── ParseInput(): Stdin JSON → hookcmd.HookInput
  ├── buildHookRegistry(): Static event → handler[] map
  └── Dispatch():
      └── RunHandlers() sequential with panic recovery:
          ├── SessionStart: [superpowers, pkgmanager]
          ├── PreToolUse:   [suggest-compact, observe-pre]
          ├── PostToolUse:  [observe-post]
          ├── PostToolUseFailure: [observe-failure]
          ├── PreCompact:   [log-compaction]
          ├── Stop:         [stop-guard (no-op)]
          └── Notification: [notify-audio (stub), notify-desktop (stub)]
```

#### Workflow 3: Session Management

```
cc-tools session <subcommand>
  ├── list [--limit N]: Store.List() → sorted by date desc → table output
  ├── info <id-or-alias>: Aliases.Resolve() → Store.Load() → JSON output
  ├── alias set <name> <id>: Aliases.Set() → persist
  ├── alias remove <name>: Aliases.Remove() → persist
  ├── aliases: Aliases.List() → table output
  └── search <query>: Store.Search() → case-insensitive match → table output
```

#### Workflow 4: Configuration

```
cc-tools config <subcommand>
  ├── show: Manager.GetAll() → formatted key=value list
  ├── get <key>: Manager.Get(key) → single value
  ├── set <key> <value>: Type-validated → Manager.Set() → persist
  └── reset [key]: Manager.Reset(key) or Manager.ResetAll()
```

#### Workflow 5: MCP Server Management

```
cc-tools mcp <subcommand>
  ├── list: Read ~/.claude/settings.json → table with name/type/scope
  ├── enable <name>: findBestMatch() → `claude mcp enable --scope user`
  ├── disable <name>: findBestMatch() → `claude mcp disable --scope user`
  ├── enable-all: List() → enable each sequentially
  └── disable-all: List() → disable each sequentially
```

### Trust Boundaries

#### Boundary 1: Stdin JSON from Claude Code

**Entry points**: `hooks.ReadHookInput()`, `hookcmd.ParseInput()`
**Trust level**: Semi-trusted (from Claude Code process, not user-controlled)
**Validation**:
- Terminal detection (reject interactive sessions)
- Empty data check
- JSON unmarshal (invalid JSON silently skipped)
- `IsEditTool()` whitelist (only 4 tools pass)
- File path extraction with tool-specific field handling

**Gap**: No schema validation beyond JSON structure. Malformed but valid JSON passes through.

#### Boundary 2: os.Args (CLI arguments)

**Entry points**: `main()`, all `run*Command()` functions
**Trust level**: User-controlled
**Validation**:
- Length checks (`minArgs`, `minSessionArgs`, `minAliasSetArgs`, etc.)
- Known command checks via switch/case with default error paths
- Numeric parsing for `--limit` values
- `hookEventMap` for event name translation

**Gap**: Skip directory paths from user args are not sanitized for directory traversal. `filepath.Abs()` is called but `..` is not rejected.

#### Boundary 3: File System (config, registry, session files)

**Trust level**: Locally trusted (user's own filesystem)
**Validation**:
- JSON unmarshal of all file reads
- Backward-compatible config format handling
- Sentinel errors for missing entries (ErrNotFound, ErrNotSkipped)

**Gap**: No integrity checks (checksums, signatures) on config/registry files. A corrupted file silently produces partial/zero data.

#### Boundary 4: External Command Execution

**Entry points**: `hooks.CommandExecutor.Execute()`, `mcp.Manager` (calls `claude` CLI), `hooks.CommandDiscovery` (calls `make -n`, `task --dry`, `just --show`, `jq`)
**Trust level**: Varies — discovered commands come from project files (Makefile, package.json, etc.)
**Validation**:
- Timeout via `context.WithTimeout()`
- Exit code extraction
- Command arguments are constructed programmatically (not shell-interpolated)
- `exec.Command()` used correctly with separate args (no shell injection)

**Gap**: Discovered commands from Makefile/package.json are executed as-is. A malicious project could contain arbitrary commands in its task runner that cc-tools would execute.

#### Boundary 5: Claude CLI Subprocess (MCP)

**Entry points**: `mcp.Manager.runCommand()`
**Trust level**: Trusted (system-installed `claude` binary)
**Validation**: Exit code checking, stderr capture for error messages.

### Complexity & Fragility Clusters

#### Cluster 1: Command Discovery (HIGH — 496 lines, most complex function)

**File**: `internal/hooks/discovery.go`
**Risk**: Highest complexity in codebase. Walks directories, probes multiple task runners, shells out to `make -n`, `task --dry`, `just --show`, `jq`. Language-specific detection with fallback chains.
**Fragility indicators**:
- 8+ external tool dependencies (make, task, just, jq, golangci-lint, cargo, ruff, etc.)
- Silent failures when tools aren't installed
- Path manipulation with filepath.Join across multiple levels
- Behavioral coupling to external tool CLI interfaces (e.g., `just --show` output format)

#### Cluster 2: Dual HookInput Structs (MEDIUM)

**Files**: `internal/hooks/input.go` and `internal/hookcmd/input.go`
**Risk**: Two separate `HookInput` structs with different fields and JSON tags. `hooks.HookInput` has `EventName`, `SessionID`, `TranscriptPath`, `Cwd` plus `ToolName`/`ToolInput`/`ToolResponse`. `hookcmd.HookInput` has `HookEventName`, `SessionID`, `TranscriptPath`, `Cwd` plus `ToolName`/`ToolInput`/`ToolResponse` and `StopHookActive`.
**Fragility indicators**:
- Field name mismatch: `EventName` vs `HookEventName`
- Different JSON tags: `event_name` vs `hook_event_name`
- Both parse from stdin but via different code paths
- `hookcmd.HookInput.HookEventName` is set programmatically after parsing (not from JSON)
- Easy to confuse which struct to use in which context

#### Cluster 3: Stdin Consumption Pattern (MEDIUM)

**File**: `cmd/cc-tools/main.go:561-618` (`debugLog()`)
**Risk**: `debugLog()` unconditionally reads all of stdin for `validate` and `hook` commands, writes it to a temp file, and replaces `os.Stdin` with the temp file. This global mutation happens before the actual command runs.
**Fragility indicators**:
- Mutates `os.Stdin` global (requires `//nolint:reassign`)
- Temp file tracked via package-level `stdinTempFile` global
- Cleanup of temp file happens in multiple locations (`runValidate()`, `runHookCommand()`)
- If temp file creation fails, stdin data is consumed but not replaced — downstream reads get nothing

#### Cluster 4: Config Manager Size (MEDIUM — 844 lines)

**File**: `internal/config/manager.go`
**Risk**: Single file handles 17 config keys with type validation, Get/Set/Reset, backward compatibility, and persistence. High cognitive load.
**Fragility indicators**:
- Large switch statement for key validation
- String-based key lookup (typos in key names silently fail)
- Backward-compatible format handling adds branching complexity
- Multiple sections with nested struct access

#### Cluster 5: Lock Manager + Cooldown (LOW-MEDIUM)

**File**: `internal/hooks/lock.go`
**Risk**: Process-level locking with PID-based stale detection. Cooldown tracking via separate file.
**Fragility indicators**:
- `Signal(0)` liveness check is not race-free (PID reuse between check and lock reclaim)
- Separate lock file and cooldown file must stay consistent
- Lock file path derived from SHA256 hash — collision theoretically possible

#### Cluster 6: Notification Handlers (LOW — stubs)

**Files**: `cmd/cc-tools/main.go:282-308`
**Risk**: `notifyAudioHandler()` and `notifyDesktopHandler()` are stubs — they check config but do nothing. The underlying `notify.Audio` and `notify.Desktop` implementations exist but aren't wired in.
**Fragility indicators**:
- Code exists in `internal/notify/` with full implementations but no way to reach them from the CLI
- Tests exist for the implementations but they're never exercised in integration

---

## Open Questions

1. **Dual HookInput convergence**: Should `hooks.HookInput` and `hookcmd.HookInput` be unified? They serve the same purpose (parsing Claude Code hook JSON) but diverge in field names and usage context.

2. **Notification handler wiring**: `notifyAudioHandler()` and `notifyDesktopHandler()` are stubs. The `internal/notify/` package has implementations. What blocks wiring them?

3. **Skip directory traversal**: `runSkipCommand()` takes a directory path from user args. `filepath.Abs()` is called but `..` traversal is not rejected. Is this intentional (user manages their own skip list)?

4. **Config key validation**: Config keys are string-based with no compile-time checking. Should a code-generated enum or constant set replace string literals?

5. **debugLog() stdin consumption**: The temp-file stdin replay pattern in `debugLog()` has a failure mode where stdin is consumed but the temp file isn't created (disk full, permissions). Should this be more defensive?

6. **Command discovery external deps**: Discovery shells out to 8+ external tools. Should there be a mode that skips task-runner probing and only uses language-specific defaults?

7. **PID reuse in lock manager**: The `Signal(0)` check + lock reclaim is not atomic. On systems with rapid PID reuse (containers), a stale lock could be claimed by a new process between the check and reclaim. Is this a practical concern?

8. **stopGuardHandler**: The Stop handler is a no-op — it checks `StopHookActive` but does nothing in either branch. Is this a placeholder for future logic or dead code?
