# Context Audit: cc-tools

**Date:** 2026-02-13 21:35 GMT+8
**Scope:** Full codebase — `cmd/cc-tools/`, `internal/`

## Module Map

```
github.com/riddopic/cc-tools (Go 1.26)

cmd/cc-tools/
  main.go      — Entry point, switch dispatch on os.Args[1]
  config.go    — config get/set/list/reset subcommands
  debug.go     — debug enable/disable/status/list/filename
  mcp.go       — mcp list/enable/disable/enable-all/disable-all
  skip.go      — skip lint/test/all/list/status + unskip

internal/hooks/        — Core validation engine (7 files)
internal/shared/       — FS interfaces, project detection, DI, colors (5 files)
internal/config/       — Config persistence (2 files)
internal/skipregistry/ — Skip persistence and registry (4 files)
internal/output/       — Terminal UI, hook formatter, tables (3 files)
internal/mcp/          — MCP server management (1 file)
internal/debug/        — Debug logging (2 files)
```

External dependencies: `charmbracelet/lipgloss` (terminal styling), `stretchr/testify` (testing).

## Function Micro-Analyses

### cmd/cc-tools/main.go

#### `main()` (L27-61)
- **Purpose:** CLI entry point. Creates terminal output, runs debug logging, dispatches to subcommand.
- **Inputs:** `os.Args` (user-controlled).
- **Effects:** Calls `debugLog()` unconditionally (reads stdin for `validate`), then dispatches.
- **Finding:** `debugLog()` reads ALL of stdin before `runValidate()` executes. This is deliberate — stdin is buffered to a temp file and `os.Stdin` is reassigned. The temp file is never cleaned up (see note below).

#### `debugLog()` (L132-188)
- **Purpose:** Log every invocation to a debug file for diagnostics.
- **Inputs:** `os.Args`, `os.Stdin`, environment variables.
- **Effects:** Reads stdin completely, writes to temp file, reassigns `os.Stdin`.
- **Finding [TEMP-FILE-LEAK]:** Temp file created at L154 (`os.CreateTemp("", "cc-tools-stdin-")`) is never deleted. Each `validate` invocation leaves a temp file in `$TMPDIR`. Over time this accumulates unboundedly.
- **Finding [STDIN-REASSIGN]:** `os.Stdin` is reassigned at L157. The `//nolint:reassign` suppresses the linter but this is a fragile pattern — if `debugLog()` order changes relative to `runValidate()`, data loss occurs.

#### `loadValidateConfig()` (L86-113)
- **Purpose:** Load timeout/cooldown from config file, allow env var override.
- **Inputs:** Config file (`~/.config/cc-tools/config.json`), env vars.
- **Analysis:** Config load errors are silently ignored (`_ =` on L91). This is intentional — missing config falls through to defaults. Env var parsing uses `strconv.Atoi` with proper error handling.

### internal/hooks/validate_skip.go

#### `ValidateWithSkipCheck()` (L16-62)
- **Purpose:** Top-level entry point from `cmd/`. Reads stdin once, checks skip registry, runs validation.
- **Inputs:** `stdin` (JSON from Claude Code hook), `debug` flag, timeout/cooldown.
- **Workflow:**
  1. Read stdin fully
  2. Parse JSON to extract `file_path`
  3. Look up project root in skip registry
  4. Build `SkipConfig` and `Dependencies`
  5. Delegate to `RunValidateHookWithSkip`
- **Finding:** If `io.ReadAll(stdin)` fails, falls through to `RunValidateHook` without skip checking — graceful degradation.

#### `checkSkipsFromInput()` (L78-147)
- **Purpose:** Parse hook JSON, find project root, check skip registry.
- **Inputs:** Raw JSON bytes.
- **Analysis:** Extracts `tool_input.file_path` from nested JSON. If project root can't be found, falls back to file directory (L116). This means skip checks work even without `.git` or `go.mod` markers, but may match against a directory that isn't the true project root.
- **Finding [SKIP-REGISTRY-PATH]:** Skip registry uses `~/.claude/skip-registry.json` (via `skipregistry.getClaudeDir()`), not the XDG config path used by `internal/config`. Two different config locations.

### internal/hooks/validate.go

#### `ParallelValidateExecutor.ExecuteValidations()` (L113-136)
- **Purpose:** Discover lint/test commands and run them in parallel.
- **Analysis:** Uses `discoverCommands` then `executeParallel`. If neither command is found, returns `BothPassed: true` — silent pass.
- **Finding:** Discovery errors from `DiscoverCommand` are silently discarded (`_, _` at L148-152). A discovery failure (e.g., timeout connecting to `task --dry`) looks identical to "no command found."

#### `executeParallel()` (L158-188)
- **Purpose:** Run lint and test concurrently using `sync.WaitGroup`.
- **Concurrency:** Uses `wg.Go()` (Go 1.22+ `sync.WaitGroup.Go`). Each goroutine writes to a different field of `ValidateResult` (`LintResult` vs `TestResult`), so no data race exists despite shared struct.
- **Analysis:** No timeout on the WaitGroup itself — the timeout is applied per-command inside `CommandExecutor.Execute()`. If a command hangs beyond the timeout context, `exec.CommandContext` kills it.

#### `runValidateHookInternal()` (L243-310)
- **Purpose:** Shared validation flow — read input, validate event, check skip file, find project root, acquire lock, execute, format output.
- **Workflow:**
  1. Read hook input (JSON from stdin)
  2. Validate it's a `PostToolUse` event for an edit tool
  3. Check `ShouldSkipFile` (vendor, node_modules, test files, generated files)
  4. Find project root
  5. Acquire lock (prevent concurrent validation + cooldown)
  6. Execute parallel validation
  7. Format result and write to stderr
- **Exit codes:** Returns 0 for pass/skip, `ExitCodeShowMessage` (2) for blocking errors.
- **Finding:** All error paths return 0 (non-blocking). Only validation failures return 2. This means Claude Code is never blocked by tool errors, only by actual lint/test failures.

### internal/hooks/executor.go

#### `CommandExecutor.Execute()` (L52-113)
- **Purpose:** Run a single command with timeout.
- **Analysis:** Creates `context.WithTimeout`, runs via `deps.Runner.RunContext`, checks for deadline exceeded vs exit error.
- **Finding:** Stdout and stderr pipes are read sequentially (L91-92) after `cmd.Start()`. Both are read with `io.ReadAll`, which blocks. If the command produces massive output, this works fine because pipes are consumed in order. However, if stderr fills its OS pipe buffer before stdout is consumed, there could theoretically be a deadlock. In practice, the timeout context prevents hanging indefinitely.

#### `ExecuteForHook()` (L116-162)
- **Purpose:** Execute command and format output for hook response.
- **Analysis:** Always returns `ExitCodeShowMessage` (2) — both on success AND failure. On success, shows "Lints pass" or "Tests pass". On failure, shows blocking error.
- **Finding [EXIT-CODE-SEMANTICS]:** Success and failure both return exit code 2. The differentiation is in the message content (green vs red ANSI). Claude Code interprets exit code 2 as "show message to user." This means `ExecuteForHook` is used by the single-command `RunSmartHook` path, not the parallel validation path.

### internal/hooks/discovery.go

#### `CommandDiscovery.DiscoverCommand()` (L50-106)
- **Purpose:** Walk up from file directory to project root, checking for lint/test commands.
- **Search order:** Makefile → Taskfile → justfile → package.json → scripts/ → language-specific.
- **Finding [DISCOVERY-PRIORITY]:** Makefile is checked before Taskfile. If a project has both, the Makefile wins even if the Taskfile is the intended runner. This is the expected behavior for backwards compatibility.

#### `checkMakefile()` / `checkTaskfile()` / `checkJustfile()` (L109-205)
- **Purpose:** Verify a target/task/recipe exists via dry-run.
- **Analysis:** Each creates a `context.WithTimeout` using the global timeout. This means discovery itself consumes timeout budget. If discovery is slow (e.g., `make -n lint` triggers a slow check), less time is available for actual execution.
- **Finding [TIMEOUT-SHARING]:** Discovery and execution share the same timeout value but create independent contexts. Total wall time could be up to 2x the configured timeout (discovery + execution). This is fine in practice because discovery dry-runs are fast.

#### `checkPackageJSON()` (L208-238)
- **Purpose:** Check for npm/yarn/pnpm scripts using `jq`.
- **Finding [JQ-DEPENDENCY]:** Requires `jq` to be installed. If `jq` is missing, package.json scripts are silently not discovered. No fallback or warning.

#### `checkGoCommands()` (L297-338)
- **Purpose:** Fallback Go detection when no build system file is found.
- **Analysis:** Tries `golangci-lint` first, falls back to `go vet`. For tests, always uses `go test ./...`.
- **Finding:** This path is only reached when Makefile/Taskfile/justfile/package.json are all absent. For cc-tools itself (which has a Taskfile), this path is never taken.

#### `ShouldSkipFile()` (in shared/project.go L156-211)
- **Purpose:** Skip validation for vendor, node_modules, generated, and test files.
- **Finding [TEST-FILE-SKIP]:** Test files (`_test.go`, `.test.js`, etc.) are skipped from validation. This means editing a test file never triggers lint/test hooks. This is intentional — test changes don't need pre-validation.

### internal/hooks/lock.go

#### `LockManager.TryAcquire()` (L73-118)
- **Purpose:** Atomic lock acquisition using `O_EXCL` file creation in `/tmp`.
- **Mechanism:**
  1. Try `CreateExclusive` (atomic, fails if file exists)
  2. If file exists, read it to check PID and cooldown timestamp
  3. If stale (process dead + past cooldown), remove and retry
- **Finding:** Lock file name uses SHA-256 of workspace dir + hook name. Collision-resistant but creates unique lock per project per hook type.
- **Finding [TOCTOU-MITIGATED]:** Between reading the stale lock and re-creating, another process could grab it. The code handles this by checking `CreateExclusive` return — if it fails, another process won. Correctly handles the race.

#### `LockManager.Release()` (L121-132)
- **Purpose:** Write completion timestamp for cooldown, don't delete the file.
- **Analysis:** Writes empty PID line + Unix timestamp. The file persists across invocations for cooldown enforcement.
- **Finding:** Lock files in `/tmp` are never explicitly cleaned up. They accumulate (one per project per hook type) but are tiny (~20 bytes each). OS temp cleanup handles eventual removal.

### internal/hooks/input.go

#### `HookInput` struct
- **Purpose:** Represents Claude Code hook JSON.
- **Fields:** `hook_event_name`, `session_id`, `transcript_path`, `cwd`, `tool_name`, `tool_input`, `tool_response`.
- **Analysis:** `ToolInput` is `json.RawMessage` — deferred parsing. Only parsed when `GetFilePath()` is called.

#### `IsEditTool()` (L77-84)
- **Purpose:** Filter for edit-related tools only.
- **Accepted tools:** `Edit`, `MultiEdit`, `Write`, `NotebookEdit`.
- **Finding:** `Bash` tool calls are not validated. This is intentional — bash commands may modify files but should not trigger full lint/test validation (too noisy).

### internal/hooks/dependencies.go

#### `Dependencies` struct (L51-59)
- **Purpose:** Dependency injection container for the hooks package.
- **Fields:** `FS` (HooksFS), `Runner` (CommandRunner), `Process` (ProcessManager), `Clock`, `Input` (InputReader), `Stdout`, `Stderr`.
- **Analysis:** All production implementations are thin wrappers around stdlib. `realCommandRunner.RunContext` sets up stdout/stderr pipes and reads sequentially.

#### `realProcessManager.ProcessExists()` (L131-139)
- **Purpose:** Check if a PID is alive using signal 0.
- **Analysis:** Unix-specific (`syscall.Signal(0)`). Works correctly on macOS/Linux. Would need platform adaptation for Windows.

### internal/shared/fs.go

#### Three filesystem interfaces
- **HooksFS:** `Stat`, `ReadFile`, `WriteFile`, `TempDir`, `CreateExclusive`, `Remove`
- **RegistryFS:** `ReadFile`, `WriteFile`, `MkdirAll`, `UserHomeDir`
- **FS:** `Stat`, `Getwd`, `Abs`
- **Finding [INTERFACE-OVERLAP]:** `ReadFile` and `WriteFile` exist in both `HooksFS` and `RegistryFS`. `Stat` exists in both `HooksFS` and `FS`. `RealFS` implements all three. The separation is for mock granularity — tests can mock exactly the FS surface they need.

#### `RealFS.CreateExclusive()` (L71-86)
- **Purpose:** Atomic file creation with `O_CREATE|O_EXCL`.
- **Analysis:** On write failure, attempts cleanup by removing the file. This is correct — partial writes should not leave corrupt lock files.

### internal/shared/project.go

#### `FindProjectRoot()` (L24-78)
- **Purpose:** Walk up directory tree looking for project markers.
- **Markers:** `.git`, `go.mod`, `package.json`, `Cargo.toml`, `setup.py`, `pyproject.toml`, `Makefile`, `justfile`, `Justfile`, `Taskfile.yml`, `Taskfile.yaml`.
- **Finding:** If no marker is found anywhere up to filesystem root, returns the original `startDir`. This means validation will still run against the file's directory even without a detected project root.

### internal/config/manager.go

#### Config persistence
- **Location:** `$XDG_CONFIG_HOME/cc-tools/config.json` or `~/.config/cc-tools/config.json`.
- **Format:** JSON with structured `Values` type.
- **Finding [BACKWARD-COMPAT]:** `loadConfig()` tries structured JSON first, then falls back to map-based config for backward compatibility (L303-311). Old configs with flat key-value maps are auto-migrated on read.
- **Finding:** Config is NOT persisted as YAML despite CLAUDE.md saying "YAML/JSON config persistence." The actual format is JSON only (`config.json`).

### internal/skipregistry/

#### Registry architecture
- **Interface:** `Reader` (IsSkipped, GetSkipTypes, ListAll) + `Writer` (AddSkip, RemoveSkip, Clear) composed into `Registry`.
- **Implementation:** `JSONRegistry` with `sync.RWMutex`, lazy-loaded cache.
- **Storage:** `JSONStorage` at `~/.claude/skip-registry.json`.
- **Finding [ATOMIC-SAVE]:** `JSONStorage.Save()` writes to `.tmp` then `os.Rename()` — atomic on most filesystems. However, `os.Rename` is used directly instead of through the `RegistryFS` interface, breaking the abstraction. Tests cannot mock this rename.
- **Finding [CACHE-COHERENCE]:** `AddSkip` and `RemoveSkip` both revert the in-memory cache if `Save()` fails (L186-194, L249-253). This prevents cache-storage divergence on write errors.

### internal/output/output.go

#### `Terminal` struct
- **Purpose:** Thread-safe terminal writer with lipgloss styling.
- **Concurrency:** `sync.Mutex` protects all write operations. Both `Write()` and `Raw()` acquire the lock.
- **Analysis:** `Raw()` uses `fmt.Fprint` (no newline), `Write()` uses `fmt.Fprintln` (with newline). This distinction is used for different output needs.

### internal/output/hook.go

#### `HookFormatter`
- **Purpose:** Format messages for Claude Code hook protocol using raw ANSI codes.
- **Analysis:** Uses `shared.ANSIGreen/Red/Yellow/Reset` constants instead of lipgloss. This is intentional — hook output must use exact ANSI codes that Claude Code expects, not lipgloss's adaptive color system.

### internal/mcp/mcp.go

#### `Manager`
- **Purpose:** Enable/disable MCP servers via `claude mcp` CLI commands.
- **Settings source:** `~/.claude/settings.json` — reads `mcpServers` map.
- **Finding [SHELL-OUT]:** All MCP operations delegate to `claude mcp` CLI commands via `exec.Command`. No direct file manipulation of Claude's config.
- **Finding [FLEXIBLE-MATCHING]:** `findMCPByName` supports partial, case-insensitive matching. "target" matches "targetprocess". This is user-friendly but could match unintended servers if names are ambiguous.

### internal/debug/

#### Two debug systems
1. **config.go / Manager:** Per-directory debug enable/disable at `~/.claude/debug-config.json`.
2. **logger.go / Logger:** Actual log file writer at `/tmp/cc-tools-validate-{name}-{hash}.log`.
- **Finding [DEBUG-PATH-MISMATCH]:** `shared.GetDebugLogPathForDir()` generates paths like `/tmp/cc-tools-{name}-{hash}.debug`, while `debug.GetLogFilePath()` generates `/tmp/cc-tools-validate-{name}-{hash}.log`. Two different naming conventions for two different log types: invocation logs vs validation logs.

## Global Understanding

### State & Invariants

**Persistent state locations:**

| State | Location | Owner |
|-------|----------|-------|
| App config | `~/.config/cc-tools/config.json` | `internal/config` |
| Skip registry | `~/.claude/skip-registry.json` | `internal/skipregistry` |
| Debug config | `~/.claude/debug-config.json` | `internal/debug` |
| Lock files | `/tmp/claude-hook-{type}-{hash}.lock` | `internal/hooks` |
| Invocation logs | `/tmp/cc-tools-{name}-{hash}.debug` | `internal/shared` |
| Validation logs | `/tmp/cc-tools-validate-{name}-{hash}.log` | `internal/debug` |
| Stdin temp files | `$TMPDIR/cc-tools-stdin-*` | `cmd/cc-tools/main.go` |

**Cross-function invariants:**

1. **Lock exclusivity:** Only one validation can run per project at a time. Enforced by `O_EXCL` lock files with PID checking and cooldown.
2. **Cache-storage consistency:** `JSONRegistry` reverts cache on failed saves. Config manager doesn't — it can diverge if write fails after in-memory update.
3. **Exit code semantics:** 0 = pass/skip (allow tool call), 2 = show message (may block). All internal errors return 0 (never block on infra failure).
4. **Skip type expansion:** `SkipTypeAll` is always expanded to `[lint, test]` before storage. "all" is never stored literally.

### Workflows

#### Primary: Validate Hook (triggered by Claude Code)

```
Claude Code PostToolUse event (Edit/Write/MultiEdit/NotebookEdit)
  → cc-tools validate (stdin = JSON)
    → main.debugLog() — log invocation, buffer stdin to temp file
    → hooks.ValidateWithSkipCheck()
      → io.ReadAll(stdin) — read buffered JSON
      → checkSkipsFromInput() — parse JSON, find project root, check skip registry
      → RunValidateHookWithSkip()
        → ReadHookInput() — parse JSON to HookInput struct
        → validateHookEvent() — filter: PostToolUse + edit tool only
        → ShouldSkipFile() — skip vendor/generated/test files
        → FindProjectRoot() — walk up for .git/go.mod/etc.
        → LockManager.TryAcquire() — atomic lock with cooldown
        → ParallelValidateExecutor.ExecuteValidations()
          → DiscoverCommand(lint) — Makefile → Taskfile → justfile → pkg.json → lang-specific
          → DiscoverCommand(test) — same hierarchy
          → executeParallel() — WaitGroup.Go for concurrent execution
            → CommandExecutor.Execute() — context.WithTimeout, exec.CommandContext
        → ValidateResult.FormatMessage() — ANSI-formatted error or pass
        → LockManager.Release() — write cooldown timestamp
    → Exit 0 (pass) or 2 (show blocking message)
```

#### Secondary: MCP Management

```
cc-tools mcp enable <name>
  → loadSettings() — read ~/.claude/settings.json
  → findMCPByName() — flexible case-insensitive matching
  → exec.Command("claude", "mcp", "add", name, command, args...)
  → Output success/error
```

#### Secondary: Skip Registry

```
cc-tools skip lint
  → os.Getwd() — get current directory
  → skipregistry.DefaultStorage() — ~/.claude/skip-registry.json
  → registry.AddSkip(dir, SkipTypeLint)
    → ensureLoaded() — lazy load with mutex
    → expandSkipType() — "all" → [lint, test]
    → cache update + storage.Save() with rollback on failure
```

### Trust Boundaries

| Boundary | Input | Trust Level | Validation |
|----------|-------|-------------|------------|
| Claude Code → cc-tools | JSON stdin | Semi-trusted | JSON parsing, event filtering, file path extraction |
| User → CLI | os.Args | Untrusted | Subcommand switch, argument count checks |
| Config file → cc-tools | JSON file | Trusted | JSON parsing with fallback defaults |
| Skip registry → validation | JSON file | Trusted | Skip type validation, path validation |
| cc-tools → external commands | Command execution | N/A (outbound) | Timeout context, exit code handling |
| MCP settings → cc-tools | JSON file | Trusted | JSON parsing |
| File system → cc-tools | File existence | Trusted | `os.Stat` checks |

**No network activity.** All operations are local filesystem + subprocess execution.

### Fragility Clusters

1. **Stdin handling in `main.go`** — Reading stdin in `debugLog()` before the command runs, buffering to temp file, reassigning `os.Stdin`. Three failure modes: temp file creation fails, file seek fails, or code ordering changes.

2. **Lock file lifecycle** — Lock files, temp files, and debug log files all accumulate in `/tmp` without cleanup. Each validation invocation creates at least one file that persists until OS cleanup.

3. **Config location inconsistency** — Three different base directories: `~/.config/cc-tools/` (app config), `~/.claude/` (skip registry + debug config), `/tmp/` (locks + logs). Split across two packages with different path resolution logic.

4. **Discovery timeout budget** — Discovery dry-runs and actual execution each create independent timeout contexts. Slow discovery could succeed, leaving less wall-clock time than expected for the actual command, though both use the same configured timeout value independently.

5. **`JSONStorage.Save()` atomicity escape** — Uses `os.Rename` directly instead of through the `RegistryFS` interface. Not mockable in tests, and the atomic rename guarantee depends on the filesystem implementation.

## Open Questions

1. **Temp file cleanup:** Should `debugLog()` clean up stdin temp files? Currently accumulates indefinitely in `$TMPDIR`.

2. **Config location consolidation:** Is there a reason for three different config base paths? Could they be unified under `~/.config/cc-tools/`?

3. **Discovery error visibility:** Should `DiscoverCommand` errors be surfaced to debug output instead of silently returning nil?

4. **`os.Rename` in `JSONStorage`:** Should this be abstracted behind `RegistryFS` for full testability?

5. **Exit code 2 for success in `ExecuteForHook`:** Is this intentional that both success and failure use exit code 2? The parallel validation path doesn't use `ExecuteForHook` — it uses `FormatMessage()` directly. `ExecuteForHook` is only used by `RunSmartHook` (single-command mode). Are both code paths actively used?
